---
title: "Building Reactive Data Apps with Shinylive and WebAssembly"
author: "Christoph Scheuch"
institute: "Founder of Tidy Intelligence"
format: 
  revealjs:
    transition: fade
    slide-number: true
    self-contained: true
    incremental: false
    theme: assets/scss/slides.scss
---

## Problems of Python web apps

- **Traditional web apps** rely on:
  - Server backend (Flask, Django, FastAPI)
  - Frontend in JavaScript or Python frameworks (e.g., Streamlit, Dash)
- Complex **state management** & data caching
- Potential **deployment** complexity

## Enter WebAssembly (Wasm)

> A binary instruction format for a stack-based virtual machine

. . .

<br>

What does this mean?

- Run compiled code (C/C++/Rust/Python) in the browser
- Near-native performance
- No hosted backend server required
- Enables static deployment (e.g., GitHub Pages, Netlify)

## Enter Shiny & Shinylive

**Shiny**: reactive data apps in pure Python
    
- No manual state management (e.g., callback functions)
- Automatic reactive execution engine
- Full support for CSS & JavaScrip customization

. . .

<br>

**Shinylive**: run Shiny apps entirely in the browser 

## Traditional Shiny deployment

![[shiny.posit.co](https://shiny.posit.co/py/get-started/shinylive.html)](assets/img/traditional-shiny-deployment.png)

## Shinylive deployment

![[shiny.posit.co](https://shiny.posit.co/py/get-started/shinylive.html)](assets/img/shinylive-deployment.png)

## Example: a simple data app in Shiny

```{.python}
import matplotlib.pyplot as plt
import numpy as np
from shiny import App, render, ui

# Define the UI
app_ui = ui.page_sidebar(
    ui.sidebar(ui.input_slider("n", "N", min=0, max=100, value=20)),
    ui.output_plot("histogram"),
    title="Hello, PyData Berlin!",
)


# Define the server logic
def server(input, output, session):
    @output
    @render.plot
    def histogram():
        np.random.seed(1234)
        x = 100 + 15 * np.random.randn(437)
        plt.hist(x, bins=input.n(), density=True)


# Create the Shiny app
app = App(app_ui, server)
```

## Building the Shinylive App

`shinylive export app docs`

```
docs
‚îú‚îÄ‚îÄ app.json          # The app's files serialized to JSON
‚îú‚îÄ‚îÄ index.html        # A web page for the application
‚îú‚îÄ‚îÄ edit
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.html    # A web page for an editor view of the application
‚îú‚îÄ‚îÄ shinylive-sw.js   # Shinylive service worker
‚îî‚îÄ‚îÄ shinylive         # Shinylive content
 ¬†¬† ‚îî‚îÄ‚îÄ pyodide       # Pyodide files
```

## Deploying the Shinylive app via GitHub Pages

![](assets/img/github-pages-deployment.png)

## Testing the deployed app

![[tidy-intelligence.github.io/pydata-berlin-2025](https://shiny.posit.co/py/get-started/shinylive.html)](assets/img/qr-code-deployed-app.png)

## Shipping Data with Parquet

- Parquet = efficient, compressed columnar data format
- Can be read in-browser using PyArrow (in Pyodide)
- Ideal for small to medium-sized datasets & offline-first apps
- Disadvantage: (potentially public) static data

## Example: Reading Parquet Files

TODO: update example to load parquet data

```python

```

## Optional Backend with FastAPI

- Offload compute or storage tasks to dedicated server
- Handle authentication, remote database access, heavy lifting
- Build API endpoints with FastAPI as needed
- Disadvantage: authentication may be complex

## Example: Fetching Data from FastAPI

TODO: extend example with 

```python

```

## Design Patterns

- **Pure client-side**: when datasets are small, apps are simple
- **Hybrid mode**: add backend for auth, heavy compute, or write access
- **Modularize**: keep server-side optional and stateless
- Use **reactive patterns** to simplify UI logic

## Limitations to Be Aware Of

- **Bundle size** (e.g., Pyodide ~14MB, Numpy ~8MB, Pandas ~13MB)
- Initial **loading time** (but caching helps)
- **Limited packages** (pure Python, no C extensions unless Wasm compiled)
- Browser **memory & performance** constraints

## When to Use This Stack

‚úÖ Great for:

- Dashboards, small data apps (potentially behind firewalls)
- Education / demos / data exploration
- Lightweight deployments (e.g. GitHub Pages)

<br>

üö´ Not ideal for:

- Real-time streaming or huge datasets
- Complex authentication or role-based access control

## Recap

- Wasm + Shinylive opens new doors for **Python in the browser**
- **Fully reactive apps** without JavaScript or explicit callbacks
- Efficient **local data** access via **Parquet**
- **Optional FastAPI** services for hybrid models

## Thank You üôè

:::: {.columns}

::: {.column width="50%"}
![[Follow on LinkedIn](https://www.linkedin.com/in/christophscheuch/)](assets/img/qr-code-linkedin.png)
:::

::: {.column width="50%"}
![GitHub Repo](assets/img/qr-code-repo.png)
:::

::::

## Resources

- WebAssembly: [webassembly.org](https://webassembly.org/)
- ShinlLive: [shiny.posit.co/py/get-started/shinylive](https://shiny.posit.co/py/get-started/shinylive.html)
- Pyodide: [pyodide.org](https://pyodide.org/)
- Apache Parquet: [parquet.apache.org](https://parquet.apache.org/)
- FastAPI: [fastapi.tiangolo.com](https://fastapi.tiangolo.com/)
- Repo: [christophscheuch/pydata-berlin-2025](https://www.github.com/christophscheuch/pydata-berlin-2025)
